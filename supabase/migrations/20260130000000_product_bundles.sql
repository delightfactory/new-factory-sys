-- ============================================================================
-- Migration: Product Bundles System (Multi-Type Support)
-- Date: 2026-01-30
-- Purpose: Complete bundle management system with all item types support
-- RISK LEVEL: ğŸŸ¢ ZERO - New tables and functions only
-- IDEMPOTENT: Safe to run multiple times
-- ============================================================================

-- ============================================================================
-- PART 1: CORE TABLES
-- ============================================================================

-- 1. Product Bundles (Ø­Ø²Ù… Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª)
CREATE TABLE IF NOT EXISTS product_bundles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    description TEXT,
    quantity NUMERIC NOT NULL DEFAULT 0,
    min_stock NUMERIC DEFAULT 0,
    unit_cost NUMERIC NOT NULL DEFAULT 0,
    bundle_price NUMERIC NOT NULL DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. Bundle Items (Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø­Ø²Ù…Ø© - ÙƒØ§ÙØ© Ø§Ù„Ø£Ù†ÙˆØ§Ø¹)
CREATE TABLE IF NOT EXISTS bundle_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    bundle_id BIGINT NOT NULL REFERENCES product_bundles(id) ON DELETE CASCADE,
    
    -- Ù†ÙˆØ¹ Ø§Ù„Ù…ÙƒÙˆÙ†
    item_type TEXT NOT NULL CHECK (item_type IN (
        'finished_product', 
        'semi_finished', 
        'raw_material', 
        'packaging_material'
    )),
    
    -- Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹ (ÙˆØ§Ø­Ø¯ ÙÙ‚Ø· Ø³ÙŠÙƒÙˆÙ† Ù„Ù‡ Ù‚ÙŠÙ…Ø© Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹)
    finished_product_id BIGINT REFERENCES finished_products(id) ON DELETE RESTRICT,
    semi_finished_product_id BIGINT REFERENCES semi_finished_products(id) ON DELETE RESTRICT,
    raw_material_id BIGINT REFERENCES raw_materials(id) ON DELETE RESTRICT,
    packaging_material_id BIGINT REFERENCES packaging_materials(id) ON DELETE RESTRICT,
    
    quantity NUMERIC NOT NULL CHECK (quantity > 0),
    unit_cost NUMERIC DEFAULT 0,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø±Ø¬Ø¹ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù…ÙˆØ¬ÙˆØ¯ Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
    CONSTRAINT valid_item_reference CHECK (
        (item_type = 'finished_product' AND finished_product_id IS NOT NULL 
            AND semi_finished_product_id IS NULL AND raw_material_id IS NULL AND packaging_material_id IS NULL) OR
        (item_type = 'semi_finished' AND semi_finished_product_id IS NOT NULL 
            AND finished_product_id IS NULL AND raw_material_id IS NULL AND packaging_material_id IS NULL) OR
        (item_type = 'raw_material' AND raw_material_id IS NOT NULL 
            AND finished_product_id IS NULL AND semi_finished_product_id IS NULL AND packaging_material_id IS NULL) OR
        (item_type = 'packaging_material' AND packaging_material_id IS NOT NULL 
            AND finished_product_id IS NULL AND semi_finished_product_id IS NULL AND raw_material_id IS NULL)
    )
);

-- ============================================================================
-- PART 2: ASSEMBLY ORDERS
-- ============================================================================

-- 3. Bundle Assembly Orders (Ø£ÙˆØ§Ù…Ø± ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø¨Ø§Ù†Ø¯Ù„Ø²)
CREATE TABLE IF NOT EXISTS bundle_assembly_orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code TEXT NOT NULL UNIQUE,
    date DATE NOT NULL DEFAULT CURRENT_DATE,
    status TEXT NOT NULL DEFAULT 'pending' 
        CHECK (status IN ('pending', 'inProgress', 'completed', 'cancelled')),
    notes TEXT,
    total_cost NUMERIC DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. Bundle Assembly Order Items
CREATE TABLE IF NOT EXISTS bundle_assembly_order_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    assembly_order_id BIGINT NOT NULL REFERENCES bundle_assembly_orders(id) ON DELETE CASCADE,
    bundle_id BIGINT NOT NULL REFERENCES product_bundles(id) ON DELETE RESTRICT,
    quantity NUMERIC NOT NULL CHECK (quantity > 0),
    unit_cost NUMERIC DEFAULT 0,
    total_cost NUMERIC DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ============================================================================
-- PART 3: INDEXES (IF NOT EXISTS pattern)
-- ============================================================================

CREATE INDEX IF NOT EXISTS idx_bundle_items_bundle ON bundle_items(bundle_id);
CREATE INDEX IF NOT EXISTS idx_bundle_items_type ON bundle_items(item_type);
CREATE INDEX IF NOT EXISTS idx_bundles_active ON product_bundles(is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_bundles_code ON product_bundles(code);
CREATE INDEX IF NOT EXISTS idx_assembly_orders_status ON bundle_assembly_orders(status);
CREATE INDEX IF NOT EXISTS idx_assembly_order_items_order ON bundle_assembly_order_items(assembly_order_id);

-- ============================================================================
-- PART 4: RPC FUNCTIONS (CREATE OR REPLACE for idempotency)
-- ============================================================================

-- 4.1 Ø­Ø³Ø§Ø¨ ØªÙƒÙ„ÙØ© Ø§Ù„Ø¨Ø§Ù†Ø¯Ù„ (ÙƒØ§ÙØ© Ø§Ù„Ø£Ù†ÙˆØ§Ø¹)
CREATE OR REPLACE FUNCTION calculate_bundle_cost(p_bundle_id BIGINT)
RETURNS NUMERIC
LANGUAGE plpgsql
AS $$
DECLARE
    v_item RECORD;
    v_total NUMERIC := 0;
    v_item_cost NUMERIC;
BEGIN
    FOR v_item IN SELECT * FROM bundle_items WHERE bundle_id = p_bundle_id LOOP
        v_item_cost := 0;
        
        IF v_item.item_type = 'finished_product' THEN
            SELECT COALESCE(unit_cost, 0) INTO v_item_cost 
            FROM finished_products WHERE id = v_item.finished_product_id;
        ELSIF v_item.item_type = 'semi_finished' THEN
            SELECT COALESCE(unit_cost, 0) INTO v_item_cost 
            FROM semi_finished_products WHERE id = v_item.semi_finished_product_id;
        ELSIF v_item.item_type = 'raw_material' THEN
            SELECT COALESCE(unit_cost, 0) INTO v_item_cost 
            FROM raw_materials WHERE id = v_item.raw_material_id;
        ELSIF v_item.item_type = 'packaging_material' THEN
            SELECT COALESCE(unit_cost, 0) INTO v_item_cost 
            FROM packaging_materials WHERE id = v_item.packaging_material_id;
        END IF;
        
        -- ØªØ­Ø¯ÙŠØ« ØªÙƒÙ„ÙØ© Ø§Ù„Ù…ÙƒÙˆÙ†
        UPDATE bundle_items SET unit_cost = v_item_cost WHERE id = v_item.id;
        
        v_total := v_total + (v_item.quantity * v_item_cost);
    END LOOP;
    
    UPDATE product_bundles SET unit_cost = v_total WHERE id = p_bundle_id;
    RETURN v_total;
END;
$$;

-- 4.2 Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙˆÙØ± Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ù„Ù„ØªØ¬Ù…ÙŠØ¹ (ÙƒØ§ÙØ© Ø§Ù„Ø£Ù†ÙˆØ§Ø¹)
CREATE OR REPLACE FUNCTION check_bundle_assembly_availability(p_bundle_id BIGINT, p_quantity NUMERIC)
RETURNS JSONB
LANGUAGE plpgsql
AS $$
DECLARE
    v_item RECORD;
    v_needed NUMERIC;
    v_available NUMERIC;
    v_name TEXT;
    v_shortages JSONB := '[]'::jsonb;
BEGIN
    FOR v_item IN SELECT * FROM bundle_items WHERE bundle_id = p_bundle_id LOOP
        v_needed := v_item.quantity * p_quantity;
        v_available := 0;
        v_name := '';
        
        IF v_item.item_type = 'finished_product' THEN
            SELECT name, quantity INTO v_name, v_available 
            FROM finished_products WHERE id = v_item.finished_product_id;
        ELSIF v_item.item_type = 'semi_finished' THEN
            SELECT name, quantity INTO v_name, v_available 
            FROM semi_finished_products WHERE id = v_item.semi_finished_product_id;
        ELSIF v_item.item_type = 'raw_material' THEN
            SELECT name, quantity INTO v_name, v_available 
            FROM raw_materials WHERE id = v_item.raw_material_id;
        ELSIF v_item.item_type = 'packaging_material' THEN
            SELECT name, quantity INTO v_name, v_available 
            FROM packaging_materials WHERE id = v_item.packaging_material_id;
        END IF;
        
        IF COALESCE(v_available, 0) < v_needed THEN
            v_shortages := v_shortages || jsonb_build_object(
                'item_type', v_item.item_type,
                'name', v_name,
                'required', v_needed,
                'available', COALESCE(v_available, 0),
                'shortage', v_needed - COALESCE(v_available, 0)
            );
        END IF;
    END LOOP;
    
    RETURN jsonb_build_object(
        'available', jsonb_array_length(v_shortages) = 0,
        'shortages', v_shortages
    );
END;
$$;

-- 4.3 ØªÙ†ÙÙŠØ° Ø£Ù…Ø± Ø§Ù„ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø°Ø±ÙŠ (ÙƒØ§ÙØ© Ø§Ù„Ø£Ù†ÙˆØ§Ø¹)
CREATE OR REPLACE FUNCTION complete_bundle_assembly_order_atomic(p_order_id BIGINT)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    r_order_item RECORD;
    r_bundle_item RECORD;
    v_order_code TEXT;
    v_qty_needed NUMERIC;
    v_prev_balance NUMERIC;
    v_new_balance NUMERIC;
    v_item_name TEXT;
    v_bundle_cost NUMERIC;
    v_prev_bundle_qty NUMERIC;
    v_prev_bundle_cost NUMERIC;
    v_new_bundle_cost NUMERIC;
    v_total_order_cost NUMERIC := 0;
    v_table_name TEXT;
    v_item_id BIGINT;
BEGIN
    -- Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ÙƒÙˆØ¯ Ø§Ù„Ø£Ù…Ø±
    SELECT code INTO v_order_code FROM bundle_assembly_orders WHERE id = p_order_id;
    IF v_order_code IS NULL THEN 
        v_order_code := 'BA-' || p_order_id::TEXT; 
    END IF;

    -- Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø£Ù…Ø±
    IF NOT EXISTS (SELECT 1 FROM bundle_assembly_orders WHERE id = p_order_id AND status = 'pending') THEN
        RAISE EXCEPTION 'Ø£Ù…Ø± Ø§Ù„ØªØ¬Ù…ÙŠØ¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ ØªÙ… ØªÙ†ÙÙŠØ°Ù‡ Ù…Ø³Ø¨Ù‚Ø§Ù‹';
    END IF;

    -- ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø© Ø¥Ù„Ù‰ Ù‚ÙŠØ¯ Ø§Ù„ØªÙ†ÙÙŠØ°
    UPDATE bundle_assembly_orders SET status = 'inProgress', updated_at = NOW() WHERE id = p_order_id;

    -- Ø§Ù„Ù…Ø±ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙ„ Ø¹Ù†ØµØ± ÙÙŠ Ø§Ù„Ø£Ù…Ø±
    FOR r_order_item IN 
        SELECT * FROM bundle_assembly_order_items WHERE assembly_order_id = p_order_id 
    LOOP
        -- Ø­Ø³Ø§Ø¨ ØªÙƒÙ„ÙØ© Ø§Ù„Ø¨Ø§Ù†Ø¯Ù„
        v_bundle_cost := calculate_bundle_cost(r_order_item.bundle_id);
        
        -- Ø®ØµÙ… Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª Ù…Ù† Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
        FOR r_bundle_item IN 
            SELECT * FROM bundle_items WHERE bundle_id = r_order_item.bundle_id
        LOOP
            v_qty_needed := r_bundle_item.quantity * r_order_item.quantity;
            v_prev_balance := 0;
            v_item_name := '';
            v_item_id := NULL;
            v_table_name := '';
            
            -- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙˆØ§Ù„Ù€ ID Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ù†ÙˆØ¹
            IF r_bundle_item.item_type = 'finished_product' THEN
                v_table_name := 'finished_products';
                v_item_id := r_bundle_item.finished_product_id;
                SELECT name, quantity INTO v_item_name, v_prev_balance 
                FROM finished_products WHERE id = v_item_id;
                
            ELSIF r_bundle_item.item_type = 'semi_finished' THEN
                v_table_name := 'semi_finished_products';
                v_item_id := r_bundle_item.semi_finished_product_id;
                SELECT name, quantity INTO v_item_name, v_prev_balance 
                FROM semi_finished_products WHERE id = v_item_id;
                
            ELSIF r_bundle_item.item_type = 'raw_material' THEN
                v_table_name := 'raw_materials';
                v_item_id := r_bundle_item.raw_material_id;
                SELECT name, quantity INTO v_item_name, v_prev_balance 
                FROM raw_materials WHERE id = v_item_id;
                
            ELSIF r_bundle_item.item_type = 'packaging_material' THEN
                v_table_name := 'packaging_materials';
                v_item_id := r_bundle_item.packaging_material_id;
                SELECT name, quantity INTO v_item_name, v_prev_balance 
                FROM packaging_materials WHERE id = v_item_id;
            END IF;
            
            -- Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±ØµÙŠØ¯
            IF COALESCE(v_prev_balance, 0) < v_qty_needed THEN
                -- Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø­Ø§Ù„Ø© Ø¥Ù„Ù‰ pending ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„
                UPDATE bundle_assembly_orders SET status = 'pending', updated_at = NOW() WHERE id = p_order_id;
                RAISE EXCEPTION 'Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙ Ù„Ù€ %: Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ % ÙˆØ§Ù„Ù…ØªØ§Ø­ %', 
                    v_item_name, v_qty_needed, COALESCE(v_prev_balance, 0);
            END IF;
            
            v_new_balance := v_prev_balance - v_qty_needed;
            
            -- Ø®ØµÙ… Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ø§Ù„Ù†ÙˆØ¹
            IF r_bundle_item.item_type = 'finished_product' THEN
                UPDATE finished_products SET quantity = v_new_balance, updated_at = NOW()
                WHERE id = v_item_id;
            ELSIF r_bundle_item.item_type = 'semi_finished' THEN
                UPDATE semi_finished_products SET quantity = v_new_balance, updated_at = NOW()
                WHERE id = v_item_id;
            ELSIF r_bundle_item.item_type = 'raw_material' THEN
                UPDATE raw_materials SET quantity = v_new_balance, updated_at = NOW()
                WHERE id = v_item_id;
            ELSIF r_bundle_item.item_type = 'packaging_material' THEN
                UPDATE packaging_materials SET quantity = v_new_balance, updated_at = NOW()
                WHERE id = v_item_id;
            END IF;
            
            -- ØªØ³Ø¬ÙŠÙ„ Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ø®Ø²ÙˆÙ†
            PERFORM log_inventory_movement(
                v_item_id,
                v_table_name,
                'out',
                v_qty_needed,
                'ØªØ¬Ù…ÙŠØ¹ Ø¨Ø§Ù†Ø¯Ù„ - Ø£Ù…Ø± #' || v_order_code,
                'BA-' || p_order_id::TEXT
            );
        END LOOP;
        
        -- Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒÙ…ÙŠØ© Ù„Ù„Ø¨Ø§Ù†Ø¯Ù„ Ù…Ø¹ Ø­Ø³Ø§Ø¨ WACO
        SELECT quantity, COALESCE(unit_cost, 0) 
        INTO v_prev_bundle_qty, v_prev_bundle_cost
        FROM product_bundles WHERE id = r_order_item.bundle_id;
        
        v_prev_bundle_qty := COALESCE(v_prev_bundle_qty, 0);
        v_new_balance := v_prev_bundle_qty + r_order_item.quantity;
        
        -- Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„ØªÙƒÙ„ÙØ© Ø§Ù„Ù…Ø±Ø¬Ø­
        IF v_new_balance > 0 THEN
            v_new_bundle_cost := ((v_prev_bundle_qty * v_prev_bundle_cost) + 
                                  (r_order_item.quantity * v_bundle_cost)) / v_new_balance;
        ELSE
            v_new_bundle_cost := v_bundle_cost;
        END IF;
        
        -- ØªØ­Ø¯ÙŠØ« Ù…Ø®Ø²ÙˆÙ† ÙˆØªÙƒÙ„ÙØ© Ø§Ù„Ø¨Ø§Ù†Ø¯Ù„
        UPDATE product_bundles 
        SET quantity = v_new_balance,
            unit_cost = v_new_bundle_cost,
            updated_at = NOW()
        WHERE id = r_order_item.bundle_id;
        
        -- ØªØ­Ø¯ÙŠØ« ØªÙƒÙ„ÙØ© Ø¹Ù†ØµØ± Ø§Ù„Ø£Ù…Ø±
        UPDATE bundle_assembly_order_items
        SET unit_cost = v_bundle_cost,
            total_cost = r_order_item.quantity * v_bundle_cost
        WHERE id = r_order_item.id;
        
        v_total_order_cost := v_total_order_cost + (r_order_item.quantity * v_bundle_cost);
    END LOOP;

    -- ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ù…Ø± ÙƒÙ…ÙƒØªÙ…Ù„
    UPDATE bundle_assembly_orders 
    SET status = 'completed',
        total_cost = v_total_order_cost,
        updated_at = NOW()
    WHERE id = p_order_id;
END;
$$;

-- 4.4 Ø¥Ù„ØºØ§Ø¡ Ø£Ù…Ø± ØªØ¬Ù…ÙŠØ¹ (Ù„Ù„Ø£ÙˆØ§Ù…Ø± ØºÙŠØ± Ø§Ù„Ù…Ù†ÙØ°Ø©)
CREATE OR REPLACE FUNCTION cancel_bundle_assembly_order(p_order_id BIGINT)
RETURNS JSONB
LANGUAGE plpgsql
AS $$
DECLARE
    v_status TEXT;
BEGIN
    SELECT status INTO v_status FROM bundle_assembly_orders WHERE id = p_order_id;
    
    IF v_status IS NULL THEN
        RETURN jsonb_build_object('success', false, 'message', 'Ø§Ù„Ø£Ù…Ø± ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
    END IF;
    
    IF v_status = 'completed' THEN
        RETURN jsonb_build_object('success', false, 'message', 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ù„ØºØ§Ø¡ Ø£Ù…Ø± ØªÙ… ØªÙ†ÙÙŠØ°Ù‡');
    END IF;
    
    IF v_status = 'cancelled' THEN
        RETURN jsonb_build_object('success', false, 'message', 'Ø§Ù„Ø£Ù…Ø± Ù…Ù„ØºÙŠ Ø¨Ø§Ù„ÙØ¹Ù„');
    END IF;
    
    UPDATE bundle_assembly_orders 
    SET status = 'cancelled', updated_at = NOW() 
    WHERE id = p_order_id;
    
    RETURN jsonb_build_object('success', true, 'message', 'ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø£Ù…Ø± Ø¨Ù†Ø¬Ø§Ø­');
END;
$$;

-- ============================================================================
-- PART 5: SALES INVOICE SUPPORT (Optional column)
-- ============================================================================

DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'sales_invoice_items' AND column_name = 'bundle_id'
    ) THEN
        ALTER TABLE sales_invoice_items 
        ADD COLUMN bundle_id BIGINT REFERENCES product_bundles(id);
    END IF;
END
$$;

-- ============================================================================
-- PART 6: RLS POLICIES (DROP IF EXISTS + CREATE pattern)
-- ============================================================================

ALTER TABLE product_bundles ENABLE ROW LEVEL SECURITY;
ALTER TABLE bundle_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE bundle_assembly_orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE bundle_assembly_order_items ENABLE ROW LEVEL SECURITY;

-- Product Bundles
DROP POLICY IF EXISTS "Auth users manage bundles" ON product_bundles;
CREATE POLICY "Auth users manage bundles" ON product_bundles
    FOR ALL TO authenticated USING (true) WITH CHECK (true);

-- Bundle Items
DROP POLICY IF EXISTS "Auth users manage bundle items" ON bundle_items;
CREATE POLICY "Auth users manage bundle items" ON bundle_items
    FOR ALL TO authenticated USING (true) WITH CHECK (true);

-- Assembly Orders
DROP POLICY IF EXISTS "Auth users manage assembly orders" ON bundle_assembly_orders;
CREATE POLICY "Auth users manage assembly orders" ON bundle_assembly_orders
    FOR ALL TO authenticated USING (true) WITH CHECK (true);

-- Assembly Order Items
DROP POLICY IF EXISTS "Auth users manage assembly items" ON bundle_assembly_order_items;
CREATE POLICY "Auth users manage assembly items" ON bundle_assembly_order_items
    FOR ALL TO authenticated USING (true) WITH CHECK (true);

-- ============================================================================
-- PART 7: COMMENTS & DOCUMENTATION
-- ============================================================================

COMMENT ON TABLE product_bundles IS 'Ø­Ø²Ù… Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª - ØªØ¬Ù…ÙŠØ¹ Ø¹Ø¯Ø© Ù…Ù†ØªØ¬Ø§Øª ÙÙŠ Ø­Ø²Ù…Ø© ÙˆØ§Ø­Ø¯Ø© Ù„Ù„Ø¨ÙŠØ¹';
COMMENT ON TABLE bundle_items IS 'Ù…ÙƒÙˆÙ†Ø§Øª Ø§Ù„Ø­Ø²Ù…Ø© - ØªØ¯Ø¹Ù… ÙƒÙ„ Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª (Ù†Ù‡Ø§Ø¦ÙŠØŒ Ù†ØµÙ Ù…ØµÙ†Ø¹ØŒ Ø®Ø§Ù…ØŒ ØªØ¹Ø¨Ø¦Ø©)';
COMMENT ON TABLE bundle_assembly_orders IS 'Ø£ÙˆØ§Ù…Ø± ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ø²Ù…';
COMMENT ON TABLE bundle_assembly_order_items IS 'Ø¹Ù†Ø§ØµØ± Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØªØ¬Ù…ÙŠØ¹';

COMMENT ON FUNCTION calculate_bundle_cost(BIGINT) IS 'Ø­Ø³Ø§Ø¨ ØªÙƒÙ„ÙØ© Ø§Ù„Ø­Ø²Ù…Ø© Ù…Ù† ØªÙƒØ§Ù„ÙŠÙ Ù…ÙƒÙˆÙ†Ø§ØªÙ‡Ø§';
COMMENT ON FUNCTION check_bundle_assembly_availability(BIGINT, NUMERIC) IS 'Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙˆÙØ± Ø§Ù„Ù…Ø®Ø²ÙˆÙ† Ù„Ù„ØªØ¬Ù…ÙŠØ¹';
COMMENT ON FUNCTION complete_bundle_assembly_order_atomic(BIGINT) IS 'ØªÙ†ÙÙŠØ° Ø£Ù…Ø± ØªØ¬Ù…ÙŠØ¹ Ø­Ø²Ù…Ø© Ø¨Ø´ÙƒÙ„ Ø°Ø±ÙŠ - ÙŠØ®ØµÙ… Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª ÙˆÙŠØ¶ÙŠÙ Ù„Ù„Ø­Ø²Ù…Ø©';
COMMENT ON FUNCTION cancel_bundle_assembly_order(BIGINT) IS 'Ø¥Ù„ØºØ§Ø¡ Ø£Ù…Ø± ØªØ¬Ù…ÙŠØ¹ ØºÙŠØ± Ù…Ù†ÙØ°';

-- ============================================================================
-- PART 8: AUTO-CODE GENERATION SEQUENCE
-- ============================================================================

-- Sequence for bundle codes
CREATE SEQUENCE IF NOT EXISTS bundle_code_seq START WITH 1;
CREATE SEQUENCE IF NOT EXISTS bundle_assembly_code_seq START WITH 1;

-- Function to generate next bundle code
CREATE OR REPLACE FUNCTION generate_bundle_code()
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
    v_next INT;
BEGIN
    SELECT COALESCE(MAX(NULLIF(regexp_replace(code, '[^0-9]', '', 'g'), '')::INT), 0) + 1
    INTO v_next
    FROM product_bundles;
    
    RETURN 'BND-' || LPAD(v_next::TEXT, 3, '0');
END;
$$;

-- Function to generate next assembly order code
CREATE OR REPLACE FUNCTION generate_bundle_assembly_code()
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
    v_next INT;
BEGIN
    SELECT COALESCE(MAX(NULLIF(regexp_replace(code, '[^0-9]', '', 'g'), '')::INT), 0) + 1
    INTO v_next
    FROM bundle_assembly_orders;
    
    RETURN 'BA-' || LPAD(v_next::TEXT, 3, '0');
END;
$$;

-- ============================================================================
-- PART 9: BUNDLE SALES INTEGRATION
-- ØªÙƒØ§Ù…Ù„ Ø¨ÙŠØ¹ Ø§Ù„Ø¨Ø§Ù†Ø¯Ù„Ø§Øª Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø§Ù„ÙÙˆØ§ØªÙŠØ± ÙˆØ§Ù„Ù…Ø±ØªØ¬Ø¹Ø§Øª
-- ============================================================================

-- 9.1 Ø¥Ø¶Ø§ÙØ© Ù‚ÙŠÙ…Ø© product_bundles Ø¥Ù„Ù‰ item_type_enum
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_enum 
        WHERE enumlabel = 'product_bundles' 
        AND enumtypid = 'item_type_enum'::regtype
    ) THEN
        ALTER TYPE item_type_enum ADD VALUE IF NOT EXISTS 'product_bundles';
    END IF;
EXCEPTION WHEN others THEN
    -- Enum value might already exist, ignore
    NULL;
END
$$;

-- 9.2 ØªØ¹Ø¯ÙŠÙ„ CHECK Constraint Ù„Ù€ item_type ÙÙŠ sales_invoice_items
ALTER TABLE sales_invoice_items 
DROP CONSTRAINT IF EXISTS sales_invoice_items_item_type_check;

ALTER TABLE sales_invoice_items 
ADD CONSTRAINT sales_invoice_items_item_type_check 
CHECK (item_type IN ('raw_material', 'packaging_material', 'finished_product', 'semi_finished', 'bundle'));

-- 9.3 ØªØ¹Ø¯ÙŠÙ„ CONSTRAINT check_sales_item_source
ALTER TABLE sales_invoice_items 
DROP CONSTRAINT IF EXISTS check_sales_item_source;

ALTER TABLE sales_invoice_items 
ADD CONSTRAINT check_sales_item_source CHECK (
    (item_type = 'raw_material' AND raw_material_id IS NOT NULL AND packaging_material_id IS NULL AND finished_product_id IS NULL AND semi_finished_product_id IS NULL AND bundle_id IS NULL) OR
    (item_type = 'packaging_material' AND packaging_material_id IS NOT NULL AND raw_material_id IS NULL AND finished_product_id IS NULL AND semi_finished_product_id IS NULL AND bundle_id IS NULL) OR
    (item_type = 'finished_product' AND finished_product_id IS NOT NULL AND raw_material_id IS NULL AND packaging_material_id IS NULL AND semi_finished_product_id IS NULL AND bundle_id IS NULL) OR
    (item_type = 'semi_finished' AND semi_finished_product_id IS NOT NULL AND raw_material_id IS NULL AND packaging_material_id IS NULL AND finished_product_id IS NULL AND bundle_id IS NULL) OR
    (item_type = 'bundle' AND bundle_id IS NOT NULL AND raw_material_id IS NULL AND packaging_material_id IS NULL AND finished_product_id IS NULL AND semi_finished_product_id IS NULL)
);

-- 9.4 Ø¥Ø¶Ø§ÙØ© bundle_id Ø¥Ù„Ù‰ sales_return_items
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_name = 'sales_return_items' AND column_name = 'bundle_id'
    ) THEN
        ALTER TABLE sales_return_items 
        ADD COLUMN bundle_id BIGINT REFERENCES product_bundles(id);
    END IF;
END
$$;

-- ============================================================================
-- PART 10: ENHANCED log_inventory_movement (Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„Ø¨Ø§Ù†Ø¯Ù„)
-- ============================================================================

CREATE OR REPLACE FUNCTION log_inventory_movement(
    p_item_id BIGINT,
    p_item_type TEXT,
    p_movement_type TEXT,
    p_quantity NUMERIC,
    p_reason TEXT,
    p_reference_id TEXT
) RETURNS VOID AS $$
DECLARE
    v_prev_balance NUMERIC;
    v_new_balance NUMERIC;
    v_table_name TEXT;
BEGIN
    IF p_item_type = 'raw_materials' OR p_item_type = 'raw_material' THEN
        SELECT quantity INTO v_new_balance FROM raw_materials WHERE id = p_item_id;
        v_table_name := 'raw_materials';
    ELSIF p_item_type = 'packaging_materials' OR p_item_type = 'packaging_material' THEN
        SELECT quantity INTO v_new_balance FROM packaging_materials WHERE id = p_item_id;
        v_table_name := 'packaging_materials';
    ELSIF p_item_type = 'semi_finished_products' OR p_item_type = 'semi_finished' THEN
        SELECT quantity INTO v_new_balance FROM semi_finished_products WHERE id = p_item_id;
        v_table_name := 'semi_finished_products';
    ELSIF p_item_type = 'finished_products' OR p_item_type = 'finished_product' THEN
        SELECT quantity INTO v_new_balance FROM finished_products WHERE id = p_item_id;
        v_table_name := 'finished_products';
    -- ===== NEW: Bundle Support =====
    ELSIF p_item_type = 'product_bundles' OR p_item_type = 'bundle' THEN
        SELECT quantity INTO v_new_balance FROM product_bundles WHERE id = p_item_id;
        v_table_name := 'product_bundles';
    -- ===============================
    ELSE
        RETURN;
    END IF;

    IF p_movement_type = 'in' THEN
        v_prev_balance := v_new_balance - p_quantity;
    ELSE
        v_prev_balance := v_new_balance + p_quantity;
    END IF;

    INSERT INTO inventory_movements (
        item_id, item_type, movement_type, quantity,
        previous_balance, new_balance, reason, reference_id
    ) VALUES (
        p_item_id, v_table_name::item_type_enum, p_movement_type, p_quantity,
        v_prev_balance, v_new_balance, p_reason, p_reference_id
    );
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- PART 11: ENHANCED process_sales_invoice (Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„Ø¨Ø§Ù†Ø¯Ù„)
-- ============================================================================

DROP FUNCTION IF EXISTS process_sales_invoice(BIGINT);

CREATE OR REPLACE FUNCTION process_sales_invoice(p_invoice_id BIGINT) RETURNS JSONB AS $$
DECLARE
    v_invoice RECORD;
    v_item RECORD;
    v_current_qty NUMERIC;
    v_current_cost NUMERIC;
    v_remaining_amount NUMERIC;
    v_item_id BIGINT;
    v_item_type_str TEXT;
BEGIN
    SELECT * INTO v_invoice FROM sales_invoices WHERE id = p_invoice_id;
    
    IF v_invoice.status != 'draft' THEN
        RAISE EXCEPTION 'Invoice is already processed or voided';
    END IF;

    FOR v_item IN SELECT * FROM sales_invoice_items WHERE invoice_id = p_invoice_id LOOP
        v_item_id := NULL;
        v_current_cost := 0;
        
        IF v_item.item_type = 'finished_product' THEN
            v_item_id := v_item.finished_product_id;
            v_item_type_str := 'finished_products';
            SELECT quantity, COALESCE(unit_cost, 0) INTO v_current_qty, v_current_cost 
            FROM finished_products WHERE id = v_item_id;
            IF v_current_qty < v_item.quantity THEN RAISE EXCEPTION 'Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙŠ Ù„Ù„Ù…Ù†ØªØ¬ #%', v_item_id; END IF;
            UPDATE finished_products SET quantity = quantity - v_item.quantity, updated_at = NOW() WHERE id = v_item_id;

        ELSIF v_item.item_type = 'raw_material' THEN
            v_item_id := v_item.raw_material_id;
            v_item_type_str := 'raw_materials';
            SELECT quantity, COALESCE(unit_cost, 0) INTO v_current_qty, v_current_cost 
            FROM raw_materials WHERE id = v_item_id;
            IF v_current_qty < v_item.quantity THEN RAISE EXCEPTION 'Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙŠ Ù„Ù„Ø®Ø§Ù…Ø© #%', v_item_id; END IF;
            UPDATE raw_materials SET quantity = quantity - v_item.quantity, updated_at = NOW() WHERE id = v_item_id;

        ELSIF v_item.item_type = 'packaging_material' THEN
            v_item_id := v_item.packaging_material_id;
            v_item_type_str := 'packaging_materials';
            SELECT quantity, COALESCE(unit_cost, 0) INTO v_current_qty, v_current_cost 
            FROM packaging_materials WHERE id = v_item_id;
            IF v_current_qty < v_item.quantity THEN RAISE EXCEPTION 'Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙŠ Ù„Ù…Ø§Ø¯Ø© Ø§Ù„ØªØ¹Ø¨Ø¦Ø© #%', v_item_id; END IF;
            UPDATE packaging_materials SET quantity = quantity - v_item.quantity, updated_at = NOW() WHERE id = v_item_id;

        ELSIF v_item.item_type = 'semi_finished' THEN
            v_item_id := v_item.semi_finished_product_id;
            v_item_type_str := 'semi_finished_products';
            SELECT quantity, COALESCE(unit_cost, 0) INTO v_current_qty, v_current_cost 
            FROM semi_finished_products WHERE id = v_item_id;
            IF v_current_qty < v_item.quantity THEN RAISE EXCEPTION 'Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙŠ Ù„Ù„Ù…Ù†ØªØ¬ Ù†ØµÙ Ø§Ù„Ù…ØµÙ†Ø¹ #%', v_item_id; END IF;
            UPDATE semi_finished_products SET quantity = quantity - v_item.quantity, updated_at = NOW() WHERE id = v_item_id;

        -- ===== NEW: Bundle Support =====
        ELSIF v_item.item_type = 'bundle' THEN
            v_item_id := v_item.bundle_id;
            v_item_type_str := 'product_bundles';
            SELECT quantity, COALESCE(unit_cost, 0) INTO v_current_qty, v_current_cost 
            FROM product_bundles WHERE id = v_item_id;
            IF v_current_qty < v_item.quantity THEN RAISE EXCEPTION 'Ø±ØµÙŠØ¯ ØºÙŠØ± ÙƒØ§ÙÙŠ Ù„Ù„Ø¨Ø§Ù†Ø¯Ù„ #%', v_item_id; END IF;
            UPDATE product_bundles SET quantity = quantity - v_item.quantity, updated_at = NOW() WHERE id = v_item_id;
        -- ===============================
        END IF;

        UPDATE sales_invoice_items SET unit_cost_at_sale = v_current_cost WHERE id = v_item.id;

        IF v_item_id IS NOT NULL THEN
            PERFORM log_inventory_movement(
                v_item_id, v_item_type_str, 'out', v_item.quantity,
                'ÙØ§ØªÙˆØ±Ø© Ø¨ÙŠØ¹ #' || v_invoice.invoice_number, 'SI-' || p_invoice_id::TEXT
            );
        END IF;
    END LOOP;

    IF v_invoice.paid_amount > 0 AND v_invoice.treasury_id IS NOT NULL THEN
        UPDATE treasuries SET balance = balance + v_invoice.paid_amount WHERE id = v_invoice.treasury_id;
        INSERT INTO financial_transactions (treasury_id, party_id, amount, transaction_type, category, description, reference_type, reference_id, transaction_date)
        VALUES (v_invoice.treasury_id, v_invoice.customer_id, v_invoice.paid_amount, 'income', 'sales_payment', 'ØªØ­ØµÙŠÙ„ ÙØ§ØªÙˆØ±Ø© Ø¨ÙŠØ¹ #' || v_invoice.invoice_number, 'sales_invoice', v_invoice.id::text, v_invoice.transaction_date);
    END IF;

    v_remaining_amount := v_invoice.total_amount - v_invoice.paid_amount;
    IF v_remaining_amount > 0 THEN
        UPDATE parties SET balance = balance + v_remaining_amount WHERE id = v_invoice.customer_id;
    END IF;

    UPDATE sales_invoices SET status = 'posted' WHERE id = p_invoice_id;
    RETURN jsonb_build_object('success', true);
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION process_sales_invoice(BIGINT) IS 
'Processes a draft sales invoice with bundle support: deducts inventory, logs movements, captures COGS, handles treasury/customer balance.';

-- ============================================================================
-- PART 12: ENHANCED void_sales_invoice (Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„Ø¨Ø§Ù†Ø¯Ù„)
-- ============================================================================

DROP FUNCTION IF EXISTS void_sales_invoice(BIGINT);

CREATE OR REPLACE FUNCTION void_sales_invoice(p_invoice_id BIGINT) RETURNS JSONB AS $$
DECLARE
    v_invoice RECORD;
    v_item RECORD;
    v_remaining_amount NUMERIC;
    v_item_id BIGINT;
    v_item_type_str TEXT;
BEGIN
    SELECT * INTO v_invoice FROM sales_invoices WHERE id = p_invoice_id;
    
    IF v_invoice.status != 'posted' THEN
        RAISE EXCEPTION 'Invoice is not posted';
    END IF;

    FOR v_item IN SELECT * FROM sales_invoice_items WHERE invoice_id = p_invoice_id LOOP
        v_item_id := NULL;
        
        IF v_item.item_type = 'raw_material' THEN
            v_item_id := v_item.raw_material_id;
            v_item_type_str := 'raw_materials';
            UPDATE raw_materials SET quantity = quantity + v_item.quantity WHERE id = v_item_id;
        ELSIF v_item.item_type = 'packaging_material' THEN
            v_item_id := v_item.packaging_material_id;
            v_item_type_str := 'packaging_materials';
            UPDATE packaging_materials SET quantity = quantity + v_item.quantity WHERE id = v_item_id;
        ELSIF v_item.item_type = 'finished_product' THEN
            v_item_id := v_item.finished_product_id;
            v_item_type_str := 'finished_products';
            UPDATE finished_products SET quantity = quantity + v_item.quantity WHERE id = v_item_id;
        ELSIF v_item.item_type = 'semi_finished' THEN
            v_item_id := v_item.semi_finished_product_id;
            v_item_type_str := 'semi_finished_products';
            UPDATE semi_finished_products SET quantity = quantity + v_item.quantity WHERE id = v_item_id;
        -- ===== NEW: Bundle Support =====
        ELSIF v_item.item_type = 'bundle' THEN
            v_item_id := v_item.bundle_id;
            v_item_type_str := 'product_bundles';
            UPDATE product_bundles SET quantity = quantity + v_item.quantity WHERE id = v_item_id;
        -- ===============================
        END IF;

        IF v_item_id IS NOT NULL THEN
            PERFORM log_inventory_movement(
                v_item_id, v_item_type_str, 'in', v_item.quantity,
                'Ø¥Ù„ØºØ§Ø¡ ÙØ§ØªÙˆØ±Ø© Ø¨ÙŠØ¹ #' || v_invoice.invoice_number, 'SI-VOID-' || p_invoice_id::TEXT
            );
        END IF;
    END LOOP;

    IF v_invoice.paid_amount > 0 AND v_invoice.treasury_id IS NOT NULL THEN
        IF (SELECT balance FROM treasuries WHERE id = v_invoice.treasury_id) < v_invoice.paid_amount THEN
             RAISE EXCEPTION 'Ø±ØµÙŠØ¯ Ø§Ù„Ø®Ø²ÙŠÙ†Ø© ØºÙŠØ± ÙƒØ§ÙÙŠ Ù„Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø¨Ù„Øº Ù„Ù„Ø¹Ù…ÙŠÙ„';
        END IF;
        UPDATE treasuries SET balance = balance - v_invoice.paid_amount WHERE id = v_invoice.treasury_id;
        INSERT INTO financial_transactions (treasury_id, party_id, amount, transaction_type, category, description, reference_type, reference_id, transaction_date)
        VALUES (v_invoice.treasury_id, v_invoice.customer_id, v_invoice.paid_amount, 'expense', 'sales_void_refund', 'Ø§Ø³ØªØ±Ø¯Ø§Ø¯ Ù…Ù† Ø¥Ù„ØºØ§Ø¡ ÙØ§ØªÙˆØ±Ø© Ø¨ÙŠØ¹ #' || v_invoice.invoice_number, 'sales_invoice', v_invoice.id::text, CURRENT_DATE);
    END IF;

    v_remaining_amount := v_invoice.total_amount - v_invoice.paid_amount;
    IF v_remaining_amount > 0 THEN
        UPDATE parties SET balance = balance - v_remaining_amount WHERE id = v_invoice.customer_id;
    END IF;

    UPDATE sales_invoices SET status = 'void' WHERE id = p_invoice_id;
    RETURN jsonb_build_object('success', true);
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION void_sales_invoice(BIGINT) IS 
'Voids a posted sales invoice with bundle support: returns inventory, reverses treasury/customer balance.';

-- ============================================================================
-- PART 13: ENHANCED process_sales_return (Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„Ø¨Ø§Ù†Ø¯Ù„)
-- ============================================================================

DROP FUNCTION IF EXISTS process_sales_return(BIGINT);

CREATE OR REPLACE FUNCTION process_sales_return(p_return_id BIGINT) 
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
    v_return RECORD;
    v_item RECORD;
    v_item_id BIGINT;
    v_item_type_str TEXT;
    v_current_cost NUMERIC;
BEGIN
    SELECT * INTO v_return FROM sales_returns WHERE id = p_return_id;
    
    IF v_return.status = 'posted' THEN 
        RAISE EXCEPTION 'Ø§Ù„Ù…Ø±ØªØ¬Ø¹ Ù…Ø¹Ø§Ù„Ø¬ Ø¨Ø§Ù„ÙØ¹Ù„'; 
    END IF;

    FOR v_item IN SELECT * FROM sales_return_items WHERE return_id = p_return_id LOOP
        v_item_id := NULL;
        v_current_cost := 0;
        
        IF v_item.item_type = 'raw_material' THEN
            v_item_id := v_item.raw_material_id;
            v_item_type_str := 'raw_materials';
            SELECT COALESCE(unit_cost, 0) INTO v_current_cost FROM raw_materials WHERE id = v_item_id;
            UPDATE raw_materials SET quantity = quantity + v_item.quantity, updated_at = NOW() WHERE id = v_item_id;
            
        ELSIF v_item.item_type = 'packaging_material' THEN
            v_item_id := v_item.packaging_material_id;
            v_item_type_str := 'packaging_materials';
            SELECT COALESCE(unit_cost, 0) INTO v_current_cost FROM packaging_materials WHERE id = v_item_id;
            UPDATE packaging_materials SET quantity = quantity + v_item.quantity, updated_at = NOW() WHERE id = v_item_id;
            
        ELSIF v_item.item_type = 'finished_product' THEN
            v_item_id := v_item.finished_product_id;
            v_item_type_str := 'finished_products';
            SELECT COALESCE(unit_cost, 0) INTO v_current_cost FROM finished_products WHERE id = v_item_id;
            UPDATE finished_products SET quantity = quantity + v_item.quantity, updated_at = NOW() WHERE id = v_item_id;
            
        ELSIF v_item.item_type = 'semi_finished' THEN
            v_item_id := v_item.semi_finished_product_id;
            v_item_type_str := 'semi_finished_products';
            SELECT COALESCE(unit_cost, 0) INTO v_current_cost FROM semi_finished_products WHERE id = v_item_id;
            UPDATE semi_finished_products SET quantity = quantity + v_item.quantity, updated_at = NOW() WHERE id = v_item_id;

        -- ===== NEW: Bundle Support =====
        ELSIF v_item.item_type = 'bundle' THEN
            v_item_id := v_item.bundle_id;
            v_item_type_str := 'product_bundles';
            SELECT COALESCE(unit_cost, 0) INTO v_current_cost FROM product_bundles WHERE id = v_item_id;
            UPDATE product_bundles SET quantity = quantity + v_item.quantity, updated_at = NOW() WHERE id = v_item_id;
        -- ===============================
        END IF;

        UPDATE sales_return_items SET unit_cost_at_return = v_current_cost WHERE id = v_item.id;

        IF v_item_id IS NOT NULL THEN
            PERFORM log_inventory_movement(
                v_item_id, v_item_type_str, 'in', v_item.quantity,
                'Ù…Ø±ØªØ¬Ø¹ Ø¨ÙŠØ¹ #' || COALESCE(v_return.return_number, v_return.id::TEXT), 'SR-' || p_return_id::TEXT
            );
        END IF;
    END LOOP;

    UPDATE parties SET balance = balance - v_return.total_amount WHERE id = v_return.customer_id;
    UPDATE sales_returns SET status = 'posted', updated_at = NOW() WHERE id = p_return_id;
END;
$$;

COMMENT ON FUNCTION process_sales_return(BIGINT) IS 
'Processes a sales return with bundle support: adds items to inventory, captures unit_cost_at_return, logs movements, updates customer balance.';

-- ============================================================================
-- PART 14: ENHANCED void_sales_return (Ù…Ø¹ Ø¯Ø¹Ù… Ø§Ù„Ø¨Ø§Ù†Ø¯Ù„)
-- ============================================================================

DROP FUNCTION IF EXISTS void_sales_return(BIGINT);

CREATE OR REPLACE FUNCTION void_sales_return(p_return_id BIGINT)
RETURNS JSONB
LANGUAGE plpgsql
AS $$
DECLARE
    v_return RECORD;
    v_item RECORD;
    v_item_id BIGINT;
    v_item_type_str TEXT;
    v_current_qty NUMERIC;
    v_return_number TEXT;
BEGIN
    SELECT * INTO v_return FROM sales_returns WHERE id = p_return_id;
    
    IF v_return IS NULL THEN
        RETURN jsonb_build_object('success', false, 'message', 'Ø§Ù„Ù…Ø±ØªØ¬Ø¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
    END IF;
    
    IF v_return.status != 'posted' THEN
        RETURN jsonb_build_object('success', false, 'message', 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ù„ØºØ§Ø¡ Ù…Ø±ØªØ¬Ø¹ ØºÙŠØ± Ù…Ø¹Ø§Ù„Ø¬');
    END IF;
    
    v_return_number := COALESCE(v_return.return_number, 'SR-' || p_return_id::TEXT);

    -- Check Stock Before Deducting
    FOR v_item IN SELECT * FROM sales_return_items WHERE return_id = p_return_id LOOP
        v_current_qty := 0;
        
        IF v_item.item_type = 'raw_material' THEN
            SELECT quantity INTO v_current_qty FROM raw_materials WHERE id = v_item.raw_material_id;
        ELSIF v_item.item_type = 'packaging_material' THEN
            SELECT quantity INTO v_current_qty FROM packaging_materials WHERE id = v_item.packaging_material_id;
        ELSIF v_item.item_type = 'finished_product' THEN
            SELECT quantity INTO v_current_qty FROM finished_products WHERE id = v_item.finished_product_id;
        ELSIF v_item.item_type = 'semi_finished' THEN
            SELECT quantity INTO v_current_qty FROM semi_finished_products WHERE id = v_item.semi_finished_product_id;
        -- ===== NEW: Bundle Support =====
        ELSIF v_item.item_type = 'bundle' THEN
            SELECT quantity INTO v_current_qty FROM product_bundles WHERE id = v_item.bundle_id;
        -- ===============================
        END IF;
        
        IF COALESCE(v_current_qty, 0) < v_item.quantity THEN
            RETURN jsonb_build_object('success', false, 'message', 'Ø±ØµÙŠØ¯ Ø§Ù„Ù…Ø®Ø²ÙˆÙ† ØºÙŠØ± ÙƒØ§ÙÙ Ù„Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù…Ø±ØªØ¬Ø¹');
        END IF;
    END LOOP;

    -- Reverse Inventory
    FOR v_item IN SELECT * FROM sales_return_items WHERE return_id = p_return_id LOOP
        v_item_id := NULL;
        
        IF v_item.item_type = 'raw_material' THEN
            v_item_id := v_item.raw_material_id;
            v_item_type_str := 'raw_materials';
            UPDATE raw_materials SET quantity = quantity - v_item.quantity, updated_at = NOW() WHERE id = v_item_id;
        ELSIF v_item.item_type = 'packaging_material' THEN
            v_item_id := v_item.packaging_material_id;
            v_item_type_str := 'packaging_materials';
            UPDATE packaging_materials SET quantity = quantity - v_item.quantity, updated_at = NOW() WHERE id = v_item_id;
        ELSIF v_item.item_type = 'finished_product' THEN
            v_item_id := v_item.finished_product_id;
            v_item_type_str := 'finished_products';
            UPDATE finished_products SET quantity = quantity - v_item.quantity, updated_at = NOW() WHERE id = v_item_id;
        ELSIF v_item.item_type = 'semi_finished' THEN
            v_item_id := v_item.semi_finished_product_id;
            v_item_type_str := 'semi_finished_products';
            UPDATE semi_finished_products SET quantity = quantity - v_item.quantity, updated_at = NOW() WHERE id = v_item_id;
        -- ===== NEW: Bundle Support =====
        ELSIF v_item.item_type = 'bundle' THEN
            v_item_id := v_item.bundle_id;
            v_item_type_str := 'product_bundles';
            UPDATE product_bundles SET quantity = quantity - v_item.quantity, updated_at = NOW() WHERE id = v_item_id;
        -- ===============================
        END IF;

        IF v_item_id IS NOT NULL THEN
            PERFORM log_inventory_movement(
                v_item_id, v_item_type_str, 'out', v_item.quantity,
                'Ø¥Ù„ØºØ§Ø¡ Ù…Ø±ØªØ¬Ø¹ Ø¨ÙŠØ¹ #' || v_return_number, 'SR-VOID-' || p_return_id::TEXT
            );
        END IF;
    END LOOP;

    UPDATE parties SET balance = balance + v_return.total_amount WHERE id = v_return.customer_id;
    UPDATE sales_returns SET status = 'void', updated_at = NOW() WHERE id = p_return_id;

    RETURN jsonb_build_object('success', true, 'message', 'ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ù…Ø±ØªØ¬Ø¹ Ø§Ù„Ø¨ÙŠØ¹ Ø¨Ù†Ø¬Ø§Ø­');
END;
$$;

COMMENT ON FUNCTION void_sales_return(BIGINT) IS 
'Voids a posted sales return with bundle support: removes items from inventory (with stock check), reverses customer balance.';

-- ============================================================================
-- END OF MIGRATION
-- ============================================================================
