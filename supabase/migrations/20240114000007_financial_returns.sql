-- Migration: Financials & Returns System
-- 1. Enhance Financial Transactions
ALTER TABLE financial_transactions 
ADD COLUMN IF NOT EXISTS invoice_id BIGINT,
ADD COLUMN IF NOT EXISTS invoice_type TEXT CHECK (invoice_type IN ('purchase', 'sales'));

-- 2. Returns Schema
-- Purchase Returns (We return to supplier)
CREATE TABLE IF NOT EXISTS purchase_returns (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    return_number TEXT,
    original_invoice_id BIGINT REFERENCES purchase_invoices(id),
    supplier_id UUID REFERENCES parties(id),
    return_date DATE DEFAULT CURRENT_DATE,
    total_amount NUMERIC NOT NULL DEFAULT 0,
    status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'posted', 'void')),
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS purchase_return_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    return_id BIGINT REFERENCES purchase_returns(id) ON DELETE CASCADE,
    item_type TEXT NOT NULL, -- raw_material, etc.
    raw_material_id BIGINT REFERENCES raw_materials(id),
    packaging_material_id BIGINT REFERENCES packaging_materials(id),
    finished_product_id BIGINT REFERENCES finished_products(id),
    semi_finished_product_id BIGINT REFERENCES semi_finished_products(id),
    quantity NUMERIC NOT NULL,
    unit_price NUMERIC NOT NULL,
    total_price NUMERIC NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Sales Returns (Customer returns to us)
CREATE TABLE IF NOT EXISTS sales_returns (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    return_number TEXT,
    original_invoice_id BIGINT REFERENCES sales_invoices(id),
    customer_id UUID REFERENCES parties(id),
    return_date DATE DEFAULT CURRENT_DATE,
    total_amount NUMERIC NOT NULL DEFAULT 0,
    status TEXT DEFAULT 'draft' CHECK (status IN ('draft', 'posted', 'void')),
    notes TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS sales_return_items (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    return_id BIGINT REFERENCES sales_returns(id) ON DELETE CASCADE,
    item_type TEXT NOT NULL,
    raw_material_id BIGINT REFERENCES raw_materials(id),
    packaging_material_id BIGINT REFERENCES packaging_materials(id),
    finished_product_id BIGINT REFERENCES finished_products(id),
    semi_finished_product_id BIGINT REFERENCES semi_finished_products(id),
    quantity NUMERIC NOT NULL,
    unit_price NUMERIC NOT NULL,
    total_price NUMERIC NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. Enhance handle_treasury_transaction
DROP FUNCTION IF EXISTS handle_treasury_transaction(bigint, numeric, text, text, text, uuid);

CREATE OR REPLACE FUNCTION handle_treasury_transaction(
    p_treasury_id BIGINT,
    p_amount NUMERIC,
    p_transaction_type TEXT, -- 'income', 'expense'
    p_category TEXT,
    p_description TEXT,
    p_party_id UUID DEFAULT NULL,
    p_invoice_id BIGINT DEFAULT NULL,
    p_invoice_type TEXT DEFAULT NULL -- 'purchase', 'sales'
) RETURNS JSONB AS $$
DECLARE
    v_new_balance NUMERIC;
    v_transaction_id BIGINT;
BEGIN
    -- Validate Amount
    IF p_amount <= 0 THEN
        RAISE EXCEPTION 'Amount must be positive';
    END IF;

    -- Update Treasury
    IF p_transaction_type = 'expense' THEN
        IF (SELECT balance FROM treasuries WHERE id = p_treasury_id) < p_amount THEN
            RAISE EXCEPTION 'Insufficient funds in treasury';
        END IF;
        UPDATE treasuries SET balance = balance - p_amount WHERE id = p_treasury_id RETURNING balance INTO v_new_balance;
    ELSIF p_transaction_type = 'income' THEN
        UPDATE treasuries SET balance = balance + p_amount WHERE id = p_treasury_id RETURNING balance INTO v_new_balance;
    ELSE
        RAISE EXCEPTION 'Invalid transaction type';
    END IF;

    -- Update Party Balance (Unified Rule)
    -- Expenses (Pay Out) -> Adds to balance (Reduces Liability / Increases Asset?? No, purely algebraic)
    -- Current Convention:
    -- Supplier Balance < 0 (Liability). We Pay (Expense) -> Balance increases (+). -1000 + 500 = -500. Correct.
    -- Customer Balance > 0 (Asset). We Pay (Refund) -> Balance increases (+). 0 + 100 = 100 (They owe us 100?? No).
    -- Wait. If we REFUND a Customer, it means we owed them (Balance was negative, or we are cancelling a receipt).
    -- If Customer Balance was 0, and we Pay 100. They have our money. Only if Loan.
    -- If Customer Balance was -100 (Advance). We Refund 100. Balance becomes 0. -100 + 100 = 0. Correct.
    -- So Expense ALWAYS ADDS (+).
    -- Income ALWAYS SUBTRACTS (-).
    -- Customer (+1000). We Receive 1000 (Income). 1000 - 1000 = 0. Correct.
    -- Supplier (Advance +1000). We Receive 500 (Refund). 1000 - 500 = 500. Correct.
    IF p_party_id IS NOT NULL THEN
        IF p_transaction_type = 'expense' THEN
            UPDATE parties SET balance = balance + p_amount WHERE id = p_party_id;
        ELSIF p_transaction_type = 'income' THEN
            UPDATE parties SET balance = balance - p_amount WHERE id = p_party_id;
        END IF;
    END IF;

    -- Update Invoice Paid Amount
    IF p_invoice_id IS NOT NULL AND p_invoice_type IS NOT NULL THEN
        IF p_invoice_type = 'purchase' THEN
            -- We are paying for this invoice (Expense). Or receiving refund (Income)?
            -- Typically Expense pays off Purchase Invoice.
            -- If Expense: paid_amount increases.
            -- If Income: paid_amount decreases (Refund)?
            IF p_transaction_type = 'expense' THEN
                UPDATE purchase_invoices SET paid_amount = paid_amount + p_amount WHERE id = p_invoice_id;
            ELSE -- Income (Refund linked to invoice)
                UPDATE purchase_invoices SET paid_amount = paid_amount - p_amount WHERE id = p_invoice_id;
            END IF;
        ELSIF p_invoice_type = 'sales' THEN
            -- We receive money for this invoice (Income).
            -- If Income: paid_amount increases.
            IF p_transaction_type = 'income' THEN
                UPDATE sales_invoices SET paid_amount = paid_amount + p_amount WHERE id = p_invoice_id;
            ELSE -- Expense (Refund)
                UPDATE sales_invoices SET paid_amount = paid_amount - p_amount WHERE id = p_invoice_id;
            END IF;
        END IF;
    END IF;

    -- Log Transaction
    INSERT INTO financial_transactions (
        treasury_id, party_id, amount, transaction_type, category, description,
        invoice_id, invoice_type, transaction_date
    ) VALUES (
        p_treasury_id, p_party_id, p_amount, p_transaction_type, p_category, p_description,
        p_invoice_id, p_invoice_type, CURRENT_DATE
    ) RETURNING id INTO v_transaction_id;

    RETURN jsonb_build_object('success', true, 'new_balance', v_new_balance, 'transaction_id', v_transaction_id);
END;
$$ LANGUAGE plpgsql;

-- 4. Process Purchase Return RPC
CREATE OR REPLACE FUNCTION process_purchase_return(p_return_id BIGINT) RETURNS VOID AS $$
DECLARE
    v_return RECORD;
    v_item RECORD;
BEGIN
    SELECT * INTO v_return FROM purchase_returns WHERE id = p_return_id;
    IF v_return.status = 'posted' THEN RAISE EXCEPTION 'Already posted'; END IF;

    -- 1. Reduce Stock (We returned items)
    FOR v_item IN SELECT * FROM purchase_return_items WHERE return_id = p_return_id LOOP
        IF v_item.item_type = 'raw_material' THEN
            UPDATE raw_materials SET quantity = quantity - v_item.quantity WHERE id = v_item.raw_material_id;
        ELSIF v_item.item_type = 'packaging_material' THEN
            UPDATE packaging_materials SET quantity = quantity - v_item.quantity WHERE id = v_item.packaging_material_id;
        ELSIF v_item.item_type = 'finished_product' THEN
            UPDATE finished_products SET quantity = quantity - v_item.quantity WHERE id = v_item.finished_product_id;
        ELSIF v_item.item_type = 'semi_finished' THEN
            UPDATE semi_finished_products SET quantity = quantity - v_item.quantity WHERE id = v_item.semi_finished_product_id;
        END IF;
    END LOOP;

    -- 2. Debit Supplier (Add to Link/Balance).
    -- Supplier Balance is Liability (Negative).
    -- We returned items -> We owe LESS (or they owe us).
    -- If Balance -1000. Return 100. Balance should be -900.
    -- So we need to ADD (+).
    UPDATE parties SET balance = balance + v_return.total_amount WHERE id = v_return.supplier_id;

    UPDATE purchase_returns SET status = 'posted', updated_at = NOW() WHERE id = p_return_id;
END;
$$ LANGUAGE plpgsql;

-- 5. Process Sales Return RPC
CREATE OR REPLACE FUNCTION process_sales_return(p_return_id BIGINT) RETURNS VOID AS $$
DECLARE
    v_return RECORD;
    v_item RECORD;
BEGIN
    SELECT * INTO v_return FROM sales_returns WHERE id = p_return_id;
    IF v_return.status = 'posted' THEN RAISE EXCEPTION 'Already posted'; END IF;

    -- 1. Increase Stock (Customer returned items)
    FOR v_item IN SELECT * FROM sales_return_items WHERE return_id = p_return_id LOOP
        IF v_item.item_type = 'raw_material' THEN
            UPDATE raw_materials SET quantity = quantity + v_item.quantity WHERE id = v_item.raw_material_id;
        ELSIF v_item.item_type = 'packaging_material' THEN
            UPDATE packaging_materials SET quantity = quantity + v_item.quantity WHERE id = v_item.packaging_material_id;
        ELSIF v_item.item_type = 'finished_product' THEN
            UPDATE finished_products SET quantity = quantity + v_item.quantity WHERE id = v_item.finished_product_id;
        ELSIF v_item.item_type = 'semi_finished' THEN
            UPDATE semi_finished_products SET quantity = quantity + v_item.quantity WHERE id = v_item.semi_finished_product_id;
        END IF;
    END LOOP;

    -- 2. Credit Customer (Subtract from Balance).
    -- Customer Balance is Asset (Positive).
    -- They returned items -> They owe LESS.
    -- If Balance +1000. Return 100. Balance should be 900.
    -- So we need to SUBTRACT (-).
    UPDATE parties SET balance = balance - v_return.total_amount WHERE id = v_return.customer_id;

    UPDATE sales_returns SET status = 'posted', updated_at = NOW() WHERE id = p_return_id;
END;
$$ LANGUAGE plpgsql;
